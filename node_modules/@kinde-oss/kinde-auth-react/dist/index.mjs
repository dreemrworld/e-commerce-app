import { K as q } from "./useKindeAuth-BArWbaqf.js";
import { u as _e } from "./useKindeAuth-BArWbaqf.js";
import { jsx as I, Fragment as B } from "react/jsx-runtime";
import { i as Q, d as W, _ as Y, y as Z, c as z, e as L, L as x, n as N, I as D, N as F, $ as J, K as ee, w as te, k as re, m as ne, g as se, h as _, f as ae, u as j, M as oe, l as ie, p as C, a as P, s as ce, o as ue } from "./index-DjNR3H6H.js";
import le, { useState as de, useRef as ge, useEffect as b, useCallback as w, useMemo as fe } from "react";
var a = /* @__PURE__ */ ((n) => (n.domain = "domain", n.clientId = "client_id", n.audience = "audience", n.redirectUri = "redirect_uri", n.logoutUri = "logout_uri", n))(a || {});
const d = new W(), G = new Q();
Y(d);
Z(G);
const U = (n) => n || window.location.origin, me = "5.5.0", we = {
  version: me
};
z.keyPrefix = "";
const he = () => {
  window.history.replaceState({}, document.title, window.location.pathname);
}, Se = {
  onSuccess: he
}, pe = ({
  audience: n,
  scope: V,
  clientId: c,
  children: $,
  domain: g,
  useInsecureForRefreshToken: M = !1,
  redirectUri: f,
  callbacks: H = {},
  logoutUri: h,
  forceChildrenRender: K = !1
}) => {
  const o = { ...Se, ...H };
  L.framework = "react", L.frameworkVersion = le.version, L.sdkVersion = we.version, z.useInsecureForRefreshToken = M;
  const [y, m] = de({
    user: void 0,
    isAuthenticated: !1,
    isLoading: !0
  }), k = ge(!1);
  b(() => {
    d.setItems({
      [a.domain]: g,
      [a.clientId]: c,
      [a.audience]: n,
      [a.redirectUri]: f,
      [a.logoutUri]: h
    });
  }, [n, V, c, g, f, h]);
  const p = w(
    async (e = {}) => {
      const t = e.state || {};
      e.state = void 0;
      const s = {
        audience: n,
        clientId: c,
        ...e,
        supportsReauth: !0,
        state: x(
          JSON.stringify({
            kinde: {
              event: "login"
              /* login */
            },
            ...t
          })
        ),
        redirectURL: U(e.redirectURL || f)
      }, u = await d.getSessionItem(
        a.domain
      ), S = await N(
        u,
        D.login,
        s
      );
      document.location = S.url.toString();
    },
    [n, c, f]
  ), T = w(
    async (e = {}) => {
      const t = e.state || {};
      e.state = void 0;
      const s = {
        ...e,
        state: x(
          JSON.stringify({
            kinde: {
              event: "register"
              /* register */
            },
            ...t
          })
        ),
        supportsReauth: !0,
        audience: await d.getSessionItem(
          a.audience
        ),
        clientId: await d.getSessionItem(
          a.clientId
        ),
        redirectURL: U(e?.redirectURL || f),
        prompt: F.create
      };
      try {
        const u = await d.getSessionItem(
          a.domain
        ), S = await N(
          u,
          D.register,
          s
        );
        document.location = S.url.toString();
      } catch (u) {
        console.error("Register error:", u), o.onError?.(
          {
            error: "ERR_REGISTER",
            errorDescription: String(u)
          },
          {},
          i
        );
      }
    },
    [f]
  ), A = w(async (e) => {
    try {
      const t = await d.getSessionItem(
        a.domain
      ), s = new URLSearchParams();
      e ? e && typeof e == "string" ? s.append("redirect", e) : typeof e == "object" && ((e.redirectUrl || h) && s.append("redirect", e.redirectUrl || h || ""), e.allSessions && s.append("all_sessions", String(e.allSessions))) : s.append("redirect", h || ""), m((u) => ({ ...u, user: void 0, isAuthenticated: !1 })), await Promise.all([
        d.destroySession(),
        G.destroySession()
      ]), document.location = `${t}/logout?${s.toString()}`;
    } catch (t) {
      console.error("Logout error:", t), o.onError?.(
        {
          error: "ERR_LOGOUT",
          errorDescription: String(t)
        },
        {},
        i
      );
    }
  }, []), i = fe(() => ({
    // Internal Methods
    login: p,
    logout: A,
    register: T,
    getIdToken: async () => await C()?.getSessionItem(P.idToken),
    getAccessToken: async () => await C()?.getSessionItem(
      P.accessToken
    ),
    /** @deprecated use `getAccessToken` instead */
    getToken: async () => await C()?.getSessionItem(
      P.accessToken
    ),
    getClaim: async (e) => ie(e),
    getClaims: async (...e) => oe(...e),
    /** @deprecated use `getCurrentOrganization` instead */
    getOrganization: async () => await j(),
    getCurrentOrganization: async () => await j(),
    getFlag: async (e) => await ae(e),
    getUserProfile: async () => _(),
    getPermission: async (e) => await se(e),
    getPermissions: async () => ne(),
    getUserOrganizations: async () => await re(),
    getRoles: async () => await te(),
    generatePortalUrl: async (e) => await ee({
      domain: g,
      returnUrl: e.returnUrl || window.location.href,
      subNav: e.subNav
    }),
    refreshToken: async (...e) => await J(...e),
    ...y
  }), [y, p, A, T]), v = w(
    (e) => {
      o.onEvent && o.onEvent("tokenRefreshed", e, i);
    },
    [o, i]
  ), R = w(() => {
    document.visibilityState === "visible" && y.isAuthenticated && J({ domain: g, clientId: c, onRefresh: v }).catch((e) => {
      console.error("Error refreshing token:", e);
    });
  }, [y.isAuthenticated, g, c, v]);
  b(() => (document.removeEventListener("visibilitychange", R), document.addEventListener("visibilitychange", R), () => {
    document.removeEventListener("visibilitychange", R);
  }), [R]);
  const O = w(async () => {
    if (k.current) return;
    await ce({ domain: g, clientId: c }), k.current = !0;
    const e = new URLSearchParams(window.location.search);
    let t, s;
    if (e.has("error")) {
      if (e.get("error")?.toLowerCase() === "login_link_expired") {
        const l = e.get("reauth_state");
        l && p({ reauthState: l });
        return;
      }
      m((l) => ({ ...l, isLoading: !1 }));
      return;
    }
    if (!e.has("code")) {
      try {
        const r = await _();
        r && m((l) => ({
          ...l,
          user: r,
          isAuthenticated: !0
        }));
      } catch (r) {
        console.warn("Error getting user profile", r);
      } finally {
        m((r) => ({ ...r, isLoading: !1 }));
      }
      return;
    }
    const S = atob(e.get("state") || "");
    try {
      t = JSON.parse(S), s = Object.assign(
        t.kinde || { event: F.login }
      );
    } catch (r) {
      console.error("Error parsing state:", r), o.onError?.(
        {
          error: "ERR_STATE_PARSE",
          errorDescription: String(r)
        },
        {},
        i
      ), t = {}, s = {
        event: "login"
        /* login */
      };
    }
    try {
      const r = await d.getSessionItem(
        a.redirectUri
      ), l = await ue({
        urlParams: new URLSearchParams(window.location.search),
        domain: g,
        clientId: c,
        redirectURL: U(r || f),
        autoRefresh: !0,
        onRefresh: v
      });
      if (l.success) {
        const E = await _();
        E && (m((X) => ({ ...X, user: E, isAuthenticated: !0 })), o.onSuccess?.(
          E,
          {
            ...t,
            kinde: void 0
          },
          i
        ), o.onEvent && o.onEvent(
          s.event,
          {
            ...t,
            kinde: void 0
          },
          i
        ));
      } else
        o.onError?.(
          {
            error: "ERR_CODE_EXCHANGE",
            errorDescription: l.error
          },
          t,
          i
        );
    } finally {
      m((r) => ({ ...r, isLoading: !1 }));
    }
  }, [c, g, f, o, i, v]);
  return b(() => {
    const e = { current: !0 };
    return e.current && O(), () => {
      e.current = !1;
    };
  }, [O]), K || k.current ? /* @__PURE__ */ I(q.Provider, { value: i, children: $ }) : /* @__PURE__ */ I(B, {});
};
export {
  q as KindeContext,
  pe as KindeProvider,
  _e as useKindeAuth
};
