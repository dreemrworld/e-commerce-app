var H = /* @__PURE__ */ ((e) => (e.email = "email", e.profile = "profile", e.openid = "openid", e.offline_access = "offline", e))(H || {}), N = /* @__PURE__ */ ((e) => (e.none = "none", e.create = "create", e.login = "login", e))(N || {}), V = /* @__PURE__ */ ((e) => (e.organizationDetails = "organization_details", e.organizationMembers = "organization_members", e.organizationPlanDetails = "organization_plan_details", e.organizationPaymentDetails = "organization_payment_details", e.organizationPlanSelection = "organization_plan_selection", e.profile = "profile", e))(V || {}), B = /* @__PURE__ */ ((e) => (e.organizationDetails = "organization_details", e.organizationMembers = "organization_members", e.organizationPlanDetails = "organization_plan_details", e.organizationPaymentDetails = "organization_payment_details", e.organizationPlanSelection = "organization_plan_selection", e.profile = "profile", e))(B || {}), I = /* @__PURE__ */ ((e) => (e.logout = "logout", e.login = "login", e.register = "registration", e.token = "token", e.profile = "profile", e))(I || {}), w = /* @__PURE__ */ ((e) => (e[e.refreshToken = 0] = "refreshToken", e[e.cookie = 1] = "cookie", e))(w || {});
const L = (e) => {
  const t = (i) => btoa(i).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  if (e instanceof ArrayBuffer) {
    const i = new Uint8Array(e), s = String.fromCharCode(...i);
    return t(s);
  }
  const n = new TextEncoder().encode(e), o = String.fromCharCode(...n);
  return t(o);
}, C = (e = 28) => {
  if (crypto) {
    const t = new Uint8Array(e / 2);
    return crypto.getRandomValues(t), Array.from(t, J).join("");
  } else
    return W(e);
};
function J(e) {
  return e.toString(16).padStart(2, "0");
}
function W(e = 28) {
  const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let r = "";
  const n = t.length;
  for (let o = 0; o < e; o++)
    r += t.charAt(Math.floor(Math.random() * n));
  return r;
}
const te = (e) => {
  e = e.split("?")[1];
  const t = new URLSearchParams(e);
  return {
    accessToken: t.get("access_token"),
    idToken: t.get("id_token"),
    expiresIn: +(t.get("expires_in") || 0)
  };
}, P = (e) => e.replace(/\/$/, ""), G = (e, t = !1) => {
  const r = Array.isArray(e.audience) ? e.audience.join(" ") : e.audience || "", n = {
    login_hint: e.loginHint,
    is_create_org: e.isCreateOrg?.toString(),
    connection_id: e.connectionId,
    redirect_uri: e.redirectURL ? t ? e.redirectURL : P(e.redirectURL) : void 0,
    audience: r,
    scope: e.scope?.join(" ") || "email profile openid offline",
    prompt: e.prompt,
    lang: e.lang,
    org_code: e.orgCode,
    org_name: e.orgName,
    has_success_page: e.hasSuccessPage?.toString(),
    workflow_deployment_id: e.workflowDeploymentId,
    supports_reauth: e.supportsReauth?.toString(),
    plan_interest: e.planInterest
  };
  return Object.keys(n).forEach(
    (o) => n[o] === void 0 && delete n[o]
  ), n;
}, U = (e) => typeof e != "object" || e === null ? e : Array.isArray(e) ? e.map((t) => U(t)) : Object.fromEntries(
  Object.entries(e).map(([t, r]) => [
    t.replace(/_([a-z])/g, (n, o) => o.toUpperCase()),
    U(r)
  ])
), Z = [
  // UTM tags
  "utm_source",
  "utm_medium",
  "utm_campaign",
  "utm_content",
  "utm_term",
  // Google Ads smart campaign tracking
  "gclid",
  "click_id",
  "hsa_acc",
  "hsa_cam",
  "hsa_grp",
  "hsa_ad",
  "hsa_src",
  "hsa_tgt",
  "hsa_kw",
  "hsa_mt",
  "hsa_net",
  "hsa_ver",
  // Marketing category
  "match_type",
  "keyword",
  "device",
  "ad_group_id",
  "campaign_id",
  "creative",
  "network",
  "ad_position",
  "fbclid",
  "li_fat_id",
  "msclkid",
  "twclid",
  "ttclid"
], ne = async (e, t = I.login, r, n) => {
  const o = `${e}/oauth2/auth`, i = T();
  if (r.reauthState)
    try {
      const u = U(
        JSON.parse(atob(r.reauthState))
      );
      r = {
        ...r,
        ...u
      }, delete r.reauthState;
    } catch (u) {
      const h = u instanceof Error ? u.message : "Unknown error";
      throw new Error(`Error handing reauth state: ${h}`);
    }
  if (!r.clientId)
    throw new Error("Error generating auth URL: Client ID missing");
  const s = {
    client_id: r.clientId,
    response_type: r.responseType || "code",
    ...G(r, n?.disableUrlSanitization)
  };
  r.state || (r.state = C(32)), i && i.setSessionItem(a.state, r.state), s.state = r.state, r.nonce || (r.nonce = C(16)), s.nonce = r.nonce, i && i.setSessionItem(a.nonce, r.nonce);
  let d = "";
  if (r.codeChallenge)
    s.code_challenge = r.codeChallenge;
  else {
    const { codeVerifier: u, codeChallenge: h } = await Q();
    d = u, i && i.setSessionItem(a.codeVerifier, u), s.code_challenge = h;
  }
  s.code_challenge_method = "S256", r.codeChallengeMethod && (s.code_challenge_method = r.codeChallengeMethod), !r.prompt && t === I.register && (s.prompt = N.create), r.properties && Object.keys(r.properties).forEach((u) => {
    if (!Z.includes(u)) {
      console.warn("Unsupported Property for url generation: ", u);
      return;
    }
    const h = r.properties?.[u];
    h !== void 0 && (s[u] = h);
  });
  const l = new URLSearchParams(s).toString();
  return {
    url: new URL(`${o}?${l}`),
    state: s.state,
    nonce: s.nonce,
    codeChallenge: s.code_challenge,
    codeVerifier: d
  };
};
async function Q() {
  const e = C(52), t = new TextEncoder().encode(e);
  let r = "";
  if (!crypto)
    r = L(btoa(e));
  else {
    const n = await crypto.subtle.digest("SHA-256", t);
    r = L(n);
  }
  return { codeVerifier: e, codeChallenge: r };
}
let v;
function F(e, t) {
  if (R(), typeof window > "u")
    throw new Error("setRefreshTimer requires a browser environment");
  if (e <= 0)
    throw new Error("Timer duration must be positive");
  v = window.setTimeout(
    t,
    Math.min(e * 1e3 - 1e4, 864e5)
  );
}
function R() {
  v !== void 0 && (window.clearTimeout(v), v = void 0);
}
const _ = {
  framework: "",
  frameworkVersion: "",
  sdkVersion: ""
}, D = async () => {
  await T()?.removeItems(
    a.state,
    a.nonce,
    a.codeVerifier
  );
}, oe = async ({
  urlParams: e,
  domain: t,
  clientId: r,
  redirectURL: n,
  autoRefresh: o = !1,
  onRefresh: i
}) => {
  const s = e.get("state"), d = e.get("code");
  if (!s || !d)
    return console.error("Invalid state or code"), {
      success: !1,
      error: "Invalid state or code"
    };
  const l = T();
  if (!l)
    return console.error("No active storage found"), {
      success: !1,
      error: "Authentication storage is not initialized"
    };
  (!_.framework || !_.frameworkVersion) && console.warn(
    "Framework and version not set. Please set the framework and version in the config object"
  );
  const u = await l.getSessionItem(a.state);
  if (s !== u)
    return console.error("Invalid state"), {
      success: !1,
      error: `Invalid state; supplied ${s}, expected ${u}`
    };
  const h = await l.getSessionItem(
    a.codeVerifier
  );
  if (h === null)
    return console.error("Code verifier not found"), {
      success: !1,
      error: "Code verifier not found"
    };
  const z = {
    "Content-type": "application/x-www-form-urlencoded; charset=UTF-8"
  };
  _.framework && (z["Kinde-SDK"] = `${_.framework}/${_.sdkVersion}/${_.frameworkVersion}/Javascript`);
  const j = {
    method: "POST",
    ...!c.useInsecureForRefreshToken && y(t) ? {
      credentials: "include"
    } : {},
    headers: new Headers(z),
    body: new URLSearchParams({
      client_id: r,
      code: d,
      code_verifier: h,
      grant_type: "authorization_code",
      redirect_uri: n
    })
  };
  let S;
  R();
  try {
    if (S = await fetch(`${t}/oauth2/token`, j), !S?.ok) {
      const m = await S.text();
      return console.error("Token exchange failed:", S.status, m), {
        success: !1,
        error: `Token exchange failed: ${S.status} - ${m}`
      };
    }
  } catch (m) {
    return D(), console.error("Token exchange failed:", m), {
      success: !1,
      error: `Token exchange failed: ${m}`
    };
  }
  const f = await S.json(), E = p();
  E && E.setItems({
    [a.accessToken]: f.access_token,
    [a.idToken]: f.id_token,
    [a.refreshToken]: f.refresh_token
  }), (c.useInsecureForRefreshToken || !y(t)) && l.setSessionItem(a.refreshToken, f.refresh_token), o && F(f.expires_in, async () => {
    $({ domain: t, clientId: r, onRefresh: i });
  }), D();
  const q = ((m) => (m.search = "", m))(new URL(window.location.toString()));
  return window.history.replaceState(window.history.state, "", q), !f.access_token || !f.id_token || !f.refresh_token ? {
    success: !1,
    error: "No access token received"
  } : {
    success: !0,
    [a.accessToken]: f.access_token,
    [a.idToken]: f.id_token,
    [a.refreshToken]: f.refresh_token
  };
};
function X(e) {
  const r = document.cookie.split("; ").find((n) => n.startsWith(`${e}=`));
  if (!r) return null;
  try {
    const n = r.split("=")[1];
    return n ? decodeURIComponent(n) : null;
  } catch (n) {
    return console.error(`Error parsing cookie ${e}:`, n), null;
  }
}
const Y = "_kbrte", se = async ({
  domain: e,
  clientId: t
}) => {
  if (!e)
    return {
      success: !1,
      error: "Domain is required for authentication check"
    };
  if (!t)
    return {
      success: !1,
      error: "Client ID is required for authentication check"
    };
  const r = y(e), n = c.useInsecureForRefreshToken;
  let o = null;
  return r && !n && (o = X(Y)), await $({
    domain: e,
    clientId: t,
    refreshType: o ? w.cookie : w.refreshToken
  });
}, y = (e) => !e.match(
  /^(?:https?:\/\/)?[a-zA-Z0-9][.-a-zA-Z0-9]*\.kinde\.com$/i
);
function b(e, t) {
  return t <= 0 ? [] : e.match(new RegExp(`.{1,${t}}`, "g")) || [];
}
var a = /* @__PURE__ */ ((e) => (e.accessToken = "accessToken", e.idToken = "idToken", e.refreshToken = "refreshToken", e.state = "state", e.nonce = "nonce", e.codeVerifier = "codeVerifier", e))(a || {});
class A {
  async setItems(t) {
    await Promise.all(
      Object.entries(t).map(
        ([r, n]) => this.setSessionItem(r, n)
      )
    );
  }
  async removeItems(...t) {
    await Promise.all(
      t.map((r) => this.removeSessionItem(r))
    );
  }
}
class ae extends A {
  memCache = {};
  /**
   * Clears all items from session store.
   * @returns {void}
   */
  async destroySession() {
    this.memCache = {};
  }
  /**
   * Sets the provided key-value store to the memory cache.
   * @param {string} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */
  async setSessionItem(t, r) {
    if (await this.removeSessionItem(t), typeof r == "string") {
      b(r, c.maxLength).forEach(
        (n, o) => {
          this.memCache[`${c.keyPrefix}${t}${o}`] = n;
        }
      );
      return;
    }
    this.memCache[`${c.keyPrefix}${String(t)}0`] = r;
  }
  /**
   * Gets the item for the provided key from the memory cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */
  async getSessionItem(t) {
    if (this.memCache[`${c.keyPrefix}${String(t)}0`] === void 0)
      return null;
    let r = "", n = 0, o = `${c.keyPrefix}${String(t)}${n}`;
    for (; this.memCache[o] !== void 0; )
      r += this.memCache[o], n++, o = `${c.keyPrefix}${String(t)}${n}`;
    return r;
  }
  /**
   * Removes the item for the provided key from the memory cache.
   * @param {string} itemKey
   * @returns {void}
   */
  async removeSessionItem(t) {
    for (const r in this.memCache)
      r.startsWith(`${c.keyPrefix}${String(t)}`) && delete this.memCache[r];
  }
}
function x(e) {
  return new Promise((t, r) => {
    chrome.storage.local.get([e], function(n) {
      chrome.runtime.lastError ? r(void 0) : t(n[e]);
    });
  });
}
class ce extends A {
  /**
   * Clears all items from session store.
   * @returns {void}
   */
  async destroySession() {
    await chrome.storage.local.clear();
  }
  /**
   * Sets the provided key-value store to the chrome.store.local.
   * @param {string} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */
  async setSessionItem(t, r) {
    if (await this.removeSessionItem(t), typeof r == "string") {
      b(r, c.maxLength).forEach(
        async (n, o) => {
          await chrome.storage.local.set({
            [`${c.keyPrefix}${t}${o}`]: n
          });
        }
      );
      return;
    }
    await chrome.storage.local.set({
      [`${c.keyPrefix}${t}0`]: r
    });
  }
  /**
   * Gets the item for the provided key from the chrome.store.local cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */
  async getSessionItem(t) {
    let r = "", n = 0, o = `${c.keyPrefix}${String(t)}${n}`;
    for (; await x(
      `${c.keyPrefix}${String(t)}${n}`
    ) !== void 0; )
      r += await x(o), n++, o = `${c.keyPrefix}${String(t)}${n}`;
    return r;
  }
  /**
   * Removes the item for the provided key from the chrome.store.local cache.
   * @param {string} itemKey
   * @returns {void}
   */
  async removeSessionItem(t) {
    let r = 0;
    for (; await x(
      `${c.keyPrefix}${String(t)}${r}`
    ) !== void 0; )
      await chrome.storage.local.remove(
        `${c.keyPrefix}${String(t)}${r}`
      ), r++;
  }
}
class ie extends A {
  constructor() {
    super(), c.useInsecureForRefreshToken && console.warn("LocalStorage store should not be used in production");
  }
  internalItems = /* @__PURE__ */ new Set();
  /**
   * Clears all items from session store.
   * @returns {void}
   */
  async destroySession() {
    this.internalItems.forEach((t) => {
      this.removeSessionItem(t);
    });
  }
  /**
   * Sets the provided key-value store to the localStorage cache.
   * @param {V} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */
  async setSessionItem(t, r) {
    if (await this.removeSessionItem(t), this.internalItems.add(t), typeof r == "string") {
      b(r, c.maxLength).forEach(
        (n, o) => {
          localStorage.setItem(
            `${c.keyPrefix}${t}${o}`,
            n
          );
        }
      );
      return;
    }
    localStorage.setItem(
      `${c.keyPrefix}${t}0`,
      r
    );
  }
  /**
   * Gets the item for the provided key from the localStorage cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */
  async getSessionItem(t) {
    if (localStorage.getItem(`${c.keyPrefix}${t}0`) === null)
      return null;
    let r = "", n = 0, o = `${c.keyPrefix}${String(t)}${n}`;
    for (; localStorage.getItem(o) !== null; )
      r += localStorage.getItem(o), n++, o = `${c.keyPrefix}${String(t)}${n}`;
    return r;
  }
  /**
   * Removes the item for the provided key from the localStorage cache.
   * @param {V} itemKey
   * @returns {void}
   */
  async removeSessionItem(t) {
    let r = 0;
    for (; localStorage.getItem(
      `${c.keyPrefix}${String(t)}${r}`
    ) !== null; )
      localStorage.removeItem(
        `${c.keyPrefix}${String(t)}${r}`
      ), r++;
    this.internalItems.delete(t);
  }
}
const c = {
  /**
   * The prefix to use for the storage keys.
   */
  keyPrefix: "kinde-",
  /**
   * The maximum length of the storage.
   *
   * If the length is exceeded the items will be split into multiple storage items.
   */
  maxLength: 2e3,
  /**
   * Use insecure storage for refresh token.
   *
   * Warning: This should only be used when you're not using a custom domain and no backend app to authenticate on.
   */
  useInsecureForRefreshToken: !1
};
function O(e, t) {
  if (!e)
    return null;
  const r = e.split(".");
  if (r.length !== 3)
    return null;
  const n = r[
    1
    /* body */
  ].replace(/-/g, "+").replace(/_/g, "/"), o = decodeURIComponent(
    atob(n).split("").map((i) => "%" + ("00" + i.charCodeAt(0).toString(16)).slice(-2)).join("")
  );
  return JSON.parse(o);
}
const k = async (e = a.accessToken) => {
  const t = p();
  if (!t)
    return null;
  const r = await t.getSessionItem(
    e === "accessToken" ? a.accessToken : a.idToken
  );
  if (!r)
    return null;
  const n = O(r);
  return n || console.warn("No decoded token found"), n;
}, M = async (e = "accessToken") => k(e), le = async (e, t = "accessToken") => {
  const r = await M(t);
  return r ? {
    name: e,
    value: r[e]
  } : null;
}, ue = async () => {
  const e = await k();
  return e ? e.org_code || e["x-hasura-org-code"] : null;
}, de = async (e = a.accessToken) => {
  const t = p();
  if (!t)
    return null;
  const r = await t.getSessionItem(
    e === "accessToken" ? a.accessToken : a.idToken
  );
  return r || null;
}, fe = async (e) => {
  const t = await k();
  if (!t)
    return null;
  const r = t.feature_flags || t["x-hasura-feature-flags"];
  return r ? r[e]?.v ?? null : null;
}, he = async () => {
  const e = await M("idToken");
  if (!e)
    return null;
  const { sub: t } = e;
  return t ? {
    id: e.sub,
    givenName: e.given_name,
    familyName: e.family_name,
    email: e.email,
    picture: e.picture
  } : (console.error("No sub in idToken"), null);
}, ge = async (e) => {
  const t = await k();
  if (!t)
    return {
      permissionKey: e,
      orgCode: null,
      isGranted: !1
    };
  const r = t.permissions || [];
  return {
    permissionKey: e,
    orgCode: t.org_code,
    isGranted: !!r.includes(e)
  };
}, me = async () => {
  const e = await k();
  if (!e)
    return {
      orgCode: null,
      permissions: []
    };
  const t = e.permissions || e["x-hasura-permissions"] || [];
  return {
    orgCode: e.org_code || e["x-hasura-org-code"],
    permissions: t
  };
}, ke = async () => {
  const e = await k("idToken");
  return e ? !e.org_codes && !e["x-hasura-org-codes"] ? (console.warn(
    "Org codes not found in token, ensure org codes have been included in the token customisation within the application settings"
  ), null) : e.org_codes || e["x-hasura-org-codes"] : null;
}, we = async () => {
  const e = await k();
  return e ? !e.roles && !e["x-hasura-roles"] ? (console.warn(
    "No roles found in token, ensure roles have been included in the token customisation within the application settings"
  ), []) : e.roles || e["x-hasura-roles"] : [];
}, Se = async (e) => {
  try {
    const t = await k("accessToken");
    if (!t) return !1;
    if (!t.exp)
      return console.error("Token does not have an expiry"), !1;
    const r = t.exp < Math.floor(Date.now() / 1e3);
    return r && e?.useRefreshToken ? (await $({
      domain: e.domain,
      clientId: e.clientId
    })).success : !r;
  } catch (t) {
    return console.error("Error checking authentication:", t), !1;
  }
}, $ = async ({
  domain: e,
  clientId: t,
  refreshType: r = w.refreshToken,
  onRefresh: n
}) => {
  const o = (d) => (n && n(d), d);
  if (!e)
    return o({
      success: !1,
      error: "Domain is required for token refresh"
    });
  if (!t)
    return o({
      success: !1,
      error: "Client ID is required for token refresh"
    });
  let i = "", s;
  if (c.useInsecureForRefreshToken || !y(e) ? s = T() : s = p(), r === w.refreshToken) {
    if (!s)
      return o({
        success: !1,
        error: "No active storage found"
      });
    if (i = await s.getSessionItem(
      a.refreshToken
    ), !i)
      return o({
        success: !1,
        error: "No refresh token found"
      });
  }
  R();
  try {
    const d = await fetch(`${P(e)}/oauth2/token`, {
      method: "POST",
      ...r === w.cookie && { credentials: "include" },
      headers: {
        "Content-type": "application/x-www-form-urlencoded; charset=UTF-8"
      },
      body: new URLSearchParams({
        ...r === w.refreshToken && {
          refresh_token: i
        },
        grant_type: "refresh_token",
        client_id: t
      }).toString()
    });
    if (!d.ok)
      return o({
        success: !1,
        error: "Failed to refresh token"
      });
    const l = await d.json();
    if (l.access_token) {
      const u = p();
      return u ? (F(l.expires_in, async () => {
        $({ domain: e, clientId: t, refreshType: r, onRefresh: n });
      }), s && (await u.setSessionItem(
        a.accessToken,
        l.access_token
      ), l.id_token && await u.setSessionItem(a.idToken, l.id_token), l.refresh_token && await s.setSessionItem(
        a.refreshToken,
        l.refresh_token
      )), o({
        success: !0,
        [a.accessToken]: l.access_token,
        [a.idToken]: l.id_token,
        [a.refreshToken]: l.refresh_token
      })) : o({
        success: !1,
        error: "No active storage found"
      });
    }
  } catch (d) {
    return o({
      success: !1,
      error: `No access token received: ${d}`
    });
  }
  return o({
    success: !1,
    error: "No access token received"
  });
}, g = {
  secure: null,
  insecure: null
}, _e = (e) => {
  g.secure = e;
}, p = () => g.secure || null, pe = () => g.secure !== null, ve = () => {
  g.secure = null;
}, ye = (e) => {
  g.insecure = e;
}, T = () => g.insecure || g.secure || null, $e = () => g.insecure !== null, Te = () => {
  g.insecure = null;
}, xe = async (e) => (console.warn(
  "Warning: generateProfileUrl is deprecated. Please use generatePortalUrl instead."
), K({
  domain: e.domain,
  returnUrl: e.returnUrl,
  subNav: e.subNav
})), K = async ({
  domain: e,
  returnUrl: t,
  subNav: r
}) => {
  const n = p();
  if (!n)
    throw new Error("generatePortalUrl: Active storage not found");
  const o = await n.getSessionItem(
    a.accessToken
  );
  if (!o)
    throw new Error("generatePortalUrl: Access Token not found");
  const i = new URLSearchParams({
    sub_nav: r || V.profile,
    return_url: t
  }), s = await fetch(
    `${P(e)}/account_api/v1/portal_link?${i.toString()}`,
    {
      headers: {
        Authorization: `Bearer ${o}`
      }
    }
  );
  if (!s.ok)
    throw new Error(
      `Failed to fetch profile URL: ${s.status} ${s.statusText}`
    );
  const d = await s.json();
  if (!d.url || typeof d.url != "string")
    throw new Error("Invalid URL received from API");
  try {
    return {
      url: new URL(d.url)
    };
  } catch (l) {
    throw console.error(l), new Error(`Invalid URL format received from API: ${d.url}`);
  }
}, Ie = {
  __esModule: !0,
  default: async () => (await import("./expoSecureStore-XvKE_bbE.js")).ExpoSecureStore
};
export {
  ke as A,
  we as B,
  Se as C,
  $ as D,
  Ie as E,
  _e as F,
  p as G,
  pe as H,
  ve as I,
  ye as J,
  T as K,
  $e as L,
  Te as M,
  ae as N,
  ce as O,
  ie as P,
  H as Q,
  N as R,
  A as S,
  V as T,
  B as U,
  I as V,
  w as W,
  a,
  c as b,
  L as c,
  P as d,
  te as e,
  ne as f,
  C as g,
  oe as h,
  se as i,
  y as j,
  F as k,
  R as l,
  G as m,
  _ as n,
  xe as o,
  K as p,
  le as q,
  M as r,
  b as s,
  ue as t,
  de as u,
  k as v,
  fe as w,
  he as x,
  ge as y,
  me as z
};
